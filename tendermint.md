# The latest gossip on BFT consensus
[原文链接](https://arxiv.org/pdf/1807.04938.pdf)
## 摘要
本文介绍了 Tendermint，这是一种用于在对抗条件下对分布式网络中的事件进行排序的新协议。该问题通常被称为拜占庭容错（BFT）共识或原子广播，由于基于区块链的数字货币（例如比特币和以太坊）的广泛成功，该问题近年来引起了广泛关注，并在公共场合成功解决了该问题没有中央权威机构的情况。Tendermint 通过依赖节点之间的点对点gossip协议，使该主题的经典学术工作现代化，并简化 BFT 算法的设计。

## I. 介绍
共识是分布式计算中最基本的问题之一。这很重要，因为它在状态机副本 (SMR) 中的作用，这是一种复制服务的通用方法，可以建模为确定性状态机[[1]]( https://lamport.azurewebsites.net/pubs/time-clocks.pdf )、[[2]]( https://dl.acm.org/doi/pdf/10.1145/98163.98167 )。这种方法的关键思想是服务副本以相同的初始状态开始，然后以相同的顺序执行请求（也称为事务）；从而保证副本彼此保持同步。SMR 方法中共识的作用是确保所有副本以相同的顺序接收事务。传统上，基于 SMR 的系统部署在数据中心设置（局域网）中，具有少量副本（三到七个），并且通常是单个管理域的一部分（例如 Chubby [[3]]( https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/chubby-osdi06.pdf )）；因此它们仅处理良性（崩溃）故障，因为更一般的故障形式（特别是恶意或拜占庭故障）被认为仅以可忽略的概率发生。  

近年来加密货币或区块链系统的成功（例如，[[4]]( https://bitcoin.org/bitcoin.pdf )、[[5]]( https://github.com/ethereum/wiki/wiki/White-Paper )）对基于 SMR 的系统的设计和部署提出了一系列全新的挑战：在大量节点之间通过广域网达成一致（数百或数千个）不属于同一管理域的节点，并且其中一部分节点可能进行恶意行为（拜占庭故障）。此外，与之前节点之间完全连接的数据中心部署相反，在区块链系统中，节点仅连接到其他节点的子集，因此通过基于 gossip 的对等协议实现通信。新的需求要求设计和算法不一定存在于拜占庭容错共识（或 SMR）系统（例如，[[6]]( https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf )、[[7]]( https://pmg.csail.mit.edu/papers/bft-tocs.pdf )）的经典学术文献中，因为主要关注的是不同的设置。  

在本文中，我们描述了一种新的拜占庭容错共识算法，它是称为 [Tendermint](https://github.com/tendermint/tendermint) 的 BFT SMR 平台的核心。Tendermint 平台包括一个用 Go 编写的高性能 BFT SMR 实现、一个用于在共识之上构建任意确定性应用程序的灵活接口，以及一套用于部署和管理的工具。

Tendermint 共识算法的灵感来自 PBFT SMR 算法 [[8]]( https://www.usenix.org/legacy/events/osdi99/full_papers/banga/banga.pdf?ref=https://githubhelp.com ) 和用于验证故障的 DLS 算法（来自 [[6]]( https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf ) 的算法 2）。与 DLS 算法类似，Tendermint 在第 2 轮中进行，其中每一轮都有一个专门的提议者（也称为协调者或领导者），并且作为正常处理的一部分，一个进程会进入新一轮（不仅是在提议者有缺陷或被怀疑为PBFT 中的足够多的进程出错）。每一轮的通信模式与 PBFT 的“正常”情况非常相似。因此，在优选的条件下（正确的提议者，正确的进程之间及时可靠的通信），Tendermint 决定分三个通信步骤（与 PBFT 相同）。  

Tendermint 共识算法的主要创新和贡献是一种新的终止机制。如 [[9]]( https://infoscience.epfl.ch/record/158894/files/WIC.pdf )、[[10]](https://infoscience.epfl.ch/record/146821/files/bcc-paper.pdf) 中所述，用于部分同步系统模型（例如 PBFT  [[8]]( https://www.usenix.org/legacy/events/osdi99/full_papers/banga/banga.pdf?ref=https://githubhelp.com ) 、[[6]]( https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf )、[[11]]( https://www.cs.cornell.edu/lorenzo/papers/Martin06Fast.pdf )）的现有 BFT 共识（和 SMR）算法通常依赖于图 1 为终止。图 1 说明了在进程开始新一轮时提议者更改期间交换的消息。它保证最终（即在某个全球稳定时间，GST 之后），存在一个具有正确提议者的轮次，这将使系统进入单一配置。直观地说，在提议的值被所有正确进程接受并且正确进程之间的通信及时可靠的一轮中，所有正确进程决定。


![figure 1](img/1.png)

**图 1：提议者（协调者）变更：p1 是新的提议者。**

为了确保提议的值被所有正确的进程接受，提议者将 
- 通过接收来自其他进程的消息来构建全局状态，
- 选择要提议的安全值，以及 
- 将选定的值与接收到的签名消息一起发送支持它的第一步。  

正确流程发送给下一个提议者的值 ![](http://latex.codecogs.com/svg.latex?v_i) 通常对应于流程认为可以接受决策的值：
- 在 PBFT [[8]]( https://www.usenix.org/legacy/events/osdi99/full_papers/banga/banga.pdf?ref=https://githubhelp.com ) 和 DLS [[6]]( https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf ) 中，它不是值本身，而是一组 ![](http://latex.codecogs.com/svg.latex?2f+1)  个具有相同值的 ![](http://latex.codecogs.com/svg.latex?id) 的签名消息
- 在 Fast Byzantine Paxos [[11]]( https://www.cs.cornell.edu/lorenzo/papers/Martin06Fast.pdf ) 中，值本身正在被发送。

在这两种情况下，在我们的系统模型中使用这种机制（即基于 *gossip* 的网络上的大量节点）将具有很高的通信复杂性，并且会随着进程数量的增加而增加：在第一种情况下，因为发送的消息取决于进程，在第二种情况下，作为值（事务区块）由每个进程发送。第一步中收到的消息集通常搭载在提议消息上（在 <span id="1">图 1</span> 中用 ![]( http://latex.codecogs.com/svg.latex?[v_1.._4]) 表示），以证明所选值 ![](http://latex.codecogs.com/svg.latex?x) 的选择是正确的。请注意，发送此消息的数量也不会随系统中的进程数量而变化。

我们为 Tendermint 设计了一种新颖的终止机制，它更适合我们考虑的系统模型。它不需要额外的通信（即不需要发送新消息，也不需要在现有消息上捎带信息），它完全基于与 PBFT [[8]]( https://www.usenix.org/legacy/events/osdi99/full_papers/banga/banga.pdf?ref=https://githubhelp.com ) 中的正常情况非常相似的通信模式。因此，在 Tendermint 中只有一种执行模式，即正常模式和恢复模式之间没有分离，这在其他类似 PBFT 的协议中也是如此（例如，[[8]]( https://www.usenix.org/legacy/events/osdi99/full_papers/banga/banga.pdf?ref=https://githubhelp.com )、[[12]]( https://www.di.fc.ul.pt/~bessani/publications/srds09-spinning.pdf ) 或 [[13]]( https://www.usenix.org/legacy/event/nsdi09/tech/full_papers/clement/clement.pdf )）。我们相信这使 Tendermint 更易于理解和正确实施。  


请注意，降低消息复杂性以提高 BFT 共识算法的可扩展性和分散性（进程数量）的正交方法是使用高级密码学（例如 Boneh-Lynn-Shacham (BLS) 签名 [[14]]( https://www.iacr.org/archive/asiacrypt2001/22480516.pdf )），例如在SBFT [[15]]( https://arxiv.org/pdf/1804.01626.pdf )。

## II. 定义
### A. 模型
我们考虑一个通过交换消息进行通信的进程系统。进程可以是正确的，也可以是错误的，其中一个错误的进程可以以任意方式运行，即我们认为是拜占庭错误。我们假设每个进程都有一定的投票权（进程的投票权可以为 0）。我们模型中的流程不是单个管理域的一部分；因此，我们不能强制所有进程之间的直接网络连接。相反，我们假设每个进程都连接到称为对等点的进程子集，这样所有正确的进程之间都存在间接通信通道。进程之间的通信是使用 *gossip* 协议 [[16]]( http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-89-1_Epidemic_Algorithms_for_Replicated_Database_Maintenance.pdf ) 建立的。

形式上，我们使用部分同步系统模型 [[6]]( https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf ) 的变体对网络通信进行建模：在系统的所有执行中，都有一个界限![]( http://latex.codecogs.com/svg.latex?\bigtriangleup) 和一个即时 ![]( http://latex.codecogs.com/svg.latex?GST )（全局稳定时间），因此 GST 之后正确进程之间的所有通信都是可靠且 ![]( http://latex.codecogs.com/svg.latex?\bigtriangleup ) 及时，即如果正确的进程 ![]( http://latex.codecogs.com/svg.latex?p) 在时间 ![]( http://latex.codecogs.com/svg.latex?t$$\geq$$GST ) 向正确的进程 ![]( http://latex.codecogs.com/svg.latex?q )  发送消息 ![]( http://latex.codecogs.com/svg.latex?m ) ，则 ![]( http://latex.codecogs.com/svg.latex?q )  将在 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup ) 之前收到 ![]( http://latex.codecogs.com/svg.latex?m ) 。除了标准的部分同步系统模型 [[6]]( https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf ) 之外，我们还假设了一个辅助属性来捕捉基于*gossip*的通信性质：

*gossip*通信：如果一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t )  发送了一些消息 ![]( http://latex.codecogs.com/svg.latex?m ) ，那么所有正确的进程都会在 ![]( http://latex.codecogs.com/svg.latex?max\\{t,GST\\}+\bigtriangleup )  之前收到 ![]( http://latex.codecogs.com/svg.latex?m ) 。此外，如果一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t )  收到一些消息 ![]( http://latex.codecogs.com/svg.latex?m ) ，那么所有正确的进程将在 ![]( http://latex.codecogs.com/svg.latex?max\\{t,GST\\}+\bigtriangleup )  之前收到 ![]( http://latex.codecogs.com/svg.latex?m ) 。

边界 ![]( http://latex.codecogs.com/svg.latex?\bigtriangleup )  和 ![]( http://latex.codecogs.com/svg.latex?GST )  是系统参数，为了我们算法的安全性，不需要知道其值。在 ![]( http://latex.codecogs.com/svg.latex?GST )  之后的有限时间内保证算法的终止。在实践中，该算法将在模型的稍弱变体中正常工作，其中系统在（足够长的）好时期（对应于系统可靠和 ![]( http://latex.codecogs.com/svg.latex?\bigtriangleup )  及时的 ![]( http://latex.codecogs.com/svg.latex?GST )  之后的时期）和坏时期（对应于 ![]( http://latex.codecogs.com/svg.latex?GST ) 之前的时期，在此期间系统是异步的并且消息可能会丢失），但考虑 ![]( http://latex.codecogs.com/svg.latex?GST ) 模型可以简化讨论。

我们假设处理步骤（可能包括发送和接收消息）花费零时间。进程配备了时钟，因此它们可以测量本地超时。由于使用了公钥加密技术，因此假设欺骗/冒充攻击在任何时候都是不可能的，即我们假设所有协议消息都包含数字签名。因此，当正确的进程 ![]( http://latex.codecogs.com/svg.latex?q ) 从其对等方接收到签名消息 ![]( http://latex.codecogs.com/svg.latex?m ) 时，进程 ![]( http://latex.codecogs.com/svg.latex?q ) 可以验证谁是消息 ![]( http://latex.codecogs.com/svg.latex?m ) 的原始发送者以及消息签名是否有效。我们没有在算法的伪代码中明确说明签名验证步骤以提高可读性；我们假设在该级别仅考虑具有有效签名的消息（并且丢弃具有无效签名的消息）。

### B. 状态机副本(SMR)
状态机复制 (SMR) 是一种复制服务的通用方法，被建模为确定性状态机 [[1]]( https://lamport.azurewebsites.net/pubs/time-clocks.pdf )、[[2]]( https://dl.acm.org/doi/pdf/10.1145/98163.98167 )。这种方法的关键思想是保证所有副本以相同的状态开始，然后以相同的顺序应用来自客户端的请求，从而保证副本的状态不会发散。在 Schneider [[2]]( https://dl.acm.org/doi/pdf/10.1145/98163.98167 ) 之后，我们注意到以下是实现状态机副本容忍（拜占庭）故障的关键：
- 副本协调。**所有 [非故障] 副本接收和处理相同的请求序列**。

此外，正如 Schneider 还指出的那样，该属性可以分解为两部分，***Agreement*** 和 ***Order***：***Agreement*** 要求所有（非故障）副本接收所有请求，而 ***Order*** 要求接收请求的顺序在所有副本中都相同。

拜占庭容错状态机副本需要确保一个额外的要求：仅执行客户端提出的请求（在 Tendermint 术语中称为事务）。在 Tendermint 中，交易验证是被副本服务的责任；在收到来自客户端的交易后，Tendermint 进程会询问服务请求是否有效，并且只会处理有效的请求。

### C. 共识
Tendermint 通过顺序执行共识实例来解决状态机复制，以就每个事务块达成一致，然后由被复制的服务执行。我们考虑拜占庭共识问题的一个变体，称为基于有效性**断言**的拜占庭共识，它是由区块链系统驱动的 [[17]]( https://arxiv.org/pdf/1702.03068.pdf )。问题由***Agreement***、***Termination***和***Validity***定义。
- ***Agreement***：没有两个正确的过程决定不同的值。
- ***Termination***：所有正确的过程最终决定一个值。
- ***Validity***：确定的值是有效的，即它满足表示为 ![]( http://latex.codecogs.com/svg.latex?valid() ) 的预定义**断言**

拜占庭共识问题的这个变体有一个特定于应用程序的 ![]( http://latex.codecogs.com/svg.latex?valid() ) 谓词来指示一个值是否有效。例如，在区块链系统的上下文中，如果一个值不包含添加到区块链的最后一个值（区块）的适当散列，则它是无效的。

## III. TENDERMINT共识算法
在本节中，我们将介绍 Tendermint 拜占庭容错共识算法。该算法由算法 1 中的伪代码列表指定。我们将该算法表示为一组原子执行的规则。我们假设进程使用 gossip 协议交换协议消息，并且接收和发送的消息都存储在每个进程的本地消息日志中。一旦消息日志包含相应条件评估为真的消息，就会触发 ***upon*** 规则。假设接收到 ![]( http://latex.codecogs.com/svg.latex?X ) 个特定类型和内容的消息的条件表示接收的消息的发送者的总投票权至少等于 ![]( http://latex.codecogs.com/svg.latex?X )。例如，条件 ![]( http://latex.codecogs.com/svg.latex?2f+1<PRECOMMIT,h_p,r,id(v)> ) , 在接收到高度 ![]( http://latex.codecogs.com/svg.latex?h_p )、一轮 ![]( http://latex.codecogs.com/svg.latex?r ) 且值等于 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息时评估为真，其发送者的总投票权至少等于 ![]( http://latex.codecogs.com/svg.latex?2f+1 )。一些规则以“第一次”结尾” 约束表示它仅在相应条件第一次评估为真时触发。这是因为这些规则并不总是改变算法变量的状态，所以没有这个约束，算法可以永远执行这些规则。具有索引 ![]( http://latex.codecogs.com/svg.latex?p ) 的变量是进程局部状态变量，而没有索引 ![]( http://latex.codecogs.com/svg.latex?p ) 的变量是值占位符。符号 ![]( http://latex.codecogs.com/svg.latex?* ) 表示任何值。
![algorithm](img/algorithm.png )  
**算法 1 Tendermint共识算法**

我们用 ![]( http://latex.codecogs.com/svg.latex?n ) 表示系统中进程的总投票权，并假设系统中故障进程的总投票权以系统参数 ![]( http://latex.codecogs.com/svg.latex?f ) 为界。该算法假设 ![]( http://latex.codecogs.com/svg.latex?n>3f )，即它要求故障进程的总投票权小于总投票权的三分之一。为简单起见，我们给出了![]( http://latex.codecogs.com/svg.latex?n=3f+1 )  的算法。

该算法分轮进行，每一轮都有一个专门的提议者。轮到提议者的映射对于所有进程都是已知的，并作为函数![]( http://latex.codecogs.com/svg.latex?proposer(h,round) )给出，返回共识实例h中一轮轮的提议者。我们假设提议者选择函数是加权循环法，其中过程与其投票权成比例地旋转。内部协议状态转换由消息接收和超时到期触发。算法 1 中存在三种超时：![]( http://latex.codecogs.com/svg.latex?timeoutPropose )、![]( http://latex.codecogs.com/svg.latex?timeoutPrevote ) 和 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit )。超时防止算法阻塞并永远等待某些条件为真，确保进程在轮次之间不断转换，并保证最终（在 ![]( http://latex.codecogs.com/svg.latex?GST ) 之后）正确进程之间的通信是及时和可靠的，因此它们可以做出决定。最后一个角色是通过增加每个新回合 ![]( http://latex.codecogs.com/svg.latex?r ) 的超时来实现的，即 ![]( http://latex.codecogs.com/svg.latex?timeoutX(r)=initTimeoutX+r*timeoutDelta ) ;每个新高度（共识实例）都会重置它们。

进程在 Tendermint 中交换以下消息：![]( http://latex.codecogs.com/svg.latex?PROPOSAL )、![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 和 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )。当前轮的提议者使用 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息来建议一个潜在的决策值，而 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 和 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 是对提议值的投票。根据 [[10]](https://infoscience.epfl.ch/record/146821/files/bcc-paper.pdf) 中对共识算法的分类，Tendermint 与 PBFT [[7]]( https://pmg.csail.mit.edu/papers/bft-tocs.pdf ) 和 DLS [[6]]( https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf ) 一样属于第 3 类，因此需要两个投票步骤（总共三个通信交换）来决定一个值。 Tendermint 共识算法是为区块链上下文设计的，其中要决定的价值是一个交易块（即它可能非常大，由许多交易组成）。因此，在算法 1（类似于 [[7]]( https://pmg.csail.mit.edu/papers/bft-tocs.pdf )）中，我们明确发送一个值（交易块）和一个小的、恒定大小的值 ![]( http://latex.codecogs.com/svg.latex?id )（一个唯一的值标识符，通常是值的哈希值，即，如果![]( http://latex.codecogs.com/svg.latex?id(v)=id(v') )，然后 ![]( http://latex.codecogs.com/svg.latex?v=v' ))。 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息是唯一携带该值的消息； ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 和 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息携带值 ![]( http://latex.codecogs.com/svg.latex?id )。在某个回合 ![]( http://latex.codecogs.com/svg.latex?r ) 中，当收到针对 ![]( http://latex.codecogs.com/svg.latex?v ) 的提案和针对 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个投票权等价的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息时，一个正确的流程会在 Tendermint 中决定值 ![]( http://latex.codecogs.com/svg.latex?v )。为了在第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮中为 ![]( http://latex.codecogs.com/svg.latex?v ) 发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息，正确的进程等待在第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮中接收相应的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 和 ![]( http://latex.codecogs.com/svg.latex?2f+1 )。否则，它会发送带有特殊 ![]( http://latex.codecogs.com/svg.latex?nil ) 值的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息。这确保了正确的进程在一轮中只能 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 一个值（或 ![]( http://latex.codecogs.com/svg.latex?nil )）。由于提议者可能是错误的，提议的值被正确的进程视为建议（它不会被盲目接受），并且正确的进程通过发送 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息来告诉其他人它是否接受了值 ![]( http://latex.codecogs.com/svg.latex?v ) 的提议；否则它会发送带有特殊 ![]( http://latex.codecogs.com/svg.latex?nil ) 值的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息。

每个进程在算法 1 中维护以下变量：![]( http://latex.codecogs.com/svg.latex?step )、![]( http://latex.codecogs.com/svg.latex?lockedValue )、![]( http://latex.codecogs.com/svg.latex?lockedRound )、![]( http://latex.codecogs.com/svg.latex?validValue ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound )。 ![]( http://latex.codecogs.com/svg.latex?step ) 表示内部 Tendermint 状态机的当前状态，即反映了本轮算法执行的阶段。锁定值存储已发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息的最新值（相对于整数）。 ![]( http://latex.codecogs.com/svg.latex?lockedRound ) 是进程发送不为零的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息的最后一轮。我们还说，一个正确的进程通过在为 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息之前设置 ![]( http://latex.codecogs.com/svg.latex?lockedValue=v ) 和 ![]( http://latex.codecogs.com/svg.latex?lockedRound=r ) 来锁定一个值 ![]( http://latex.codecogs.com/svg.latex?v )。由于只有在收到 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个针对 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息时，正确的进程才能确定值 ![]( http://latex.codecogs.com/svg.latex?v )，这意味着可能的决策值是由至少 ![]( http://latex.codecogs.com/svg.latex?f+1 ) 等效于正确进程的投票权锁定的值。因此，在某个回合 ![]( http://latex.codecogs.com/svg.latex?r ) 中接收到 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 和 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 的相应 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息的任何值 ![]( http://latex.codecogs.com/svg.latex?v ) 都是可能的决策值。 ![]( http://latex.codecogs.com/svg.latex?validValue ) 变量的作用是存储最近可能的决策值； ![]( http://latex.codecogs.com/svg.latex?validRound ) 是更新 ![]( http://latex.codecogs.com/svg.latex?validValue ) 的最后一轮。除了这些变量之外，进程还存储当前共识实例（![]( http://latex.codecogs.com/svg.latex?h_p )，在 Tendermint 中称为高度）和当前轮数（![]( http://latex.codecogs.com/svg.latex?round_p )）并将它们附加到每条消息。最后，一个进程还存储了一系列决策，![]( http://latex.codecogs.com/svg.latex?decision_p )（Tendermint 假设一系列共识实例，每个高度一个）。

每一轮都由一个提议者通过 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息建议一个值开始（见第 19 行）。在每个高度的初始轮次中，提议者可以自由选择要建议的值。在算法 1 中，正确的过程使用外部函数 ![]( http://latex.codecogs.com/svg.latex?getValue() ) 获得要提议的值，该函数返回要提议的有效值。在接下来的几轮中，只有当 ![]( http://latex.codecogs.com/svg.latex?validValue=nil ) 时，一个正确的提议者才会建议一个新值；否则建议使用有效值（见第 15-18 行）。除了提议的值之外，![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息还包含 ![]( http://latex.codecogs.com/svg.latex?validRound ) ，因此其他进程被告知有关提议者将 ![]( http://latex.codecogs.com/svg.latex?validValue ) 值作为可能的决策值的最后一轮。请注意，如果正确的提议者 ![]( http://latex.codecogs.com/svg.latex?p ) 在 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 中发送带有 ![]( http://latex.codecogs.com/svg.latex?validRound ) 的 ![]( http://latex.codecogs.com/svg.latex?validValue )，这意味着进程 ![]( http://latex.codecogs.com/svg.latex?p ) 在该轮 ![]( http://latex.codecogs.com/svg.latex?validRound ) 中收到了 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 和相应的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息。如果一个正确的进程在时间 ![]( http://latex.codecogs.com/svg.latex?t>GST ) 发送了具有有效值 ( ![]( http://latex.codecogs.com/svg.latex?validRound>-1 ) ) 的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息，则根据 Gossip 通信属性，所有正确的进程将在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup ) 之前收到相应的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 和 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息。因此，所有正确的过程都将能够验证建议值的正确性，因为它得到了 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 和相应的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 投票权等价的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息的支持。

如果外部有效函数对值 ![]( http://latex.codecogs.com/svg.latex?v ) 返回 *true*，并且 ![]( http://latex.codecogs.com/svg.latex?p ) 没有锁定任何值 ( ![]( http://latex.codecogs.com/svg.latex?lockedRound=-1 ) ) 或 ![]( http://latex.codecogs.com/svg.latex?p ) 有锁定值 ![]( http://latex.codecogs.com/svg.latex?v(lockedValue=v) );见第 23 行。如果提议的对是 ( ![]( http://latex.codecogs.com/svg.latex?v,v_r$$\geq$$0 ) ) 并且正确的进程 ![]( http://latex.codecogs.com/svg.latex?p ) 锁定了某个值，如果它是更近的可能决策值、![]( http://latex.codecogs.com/svg.latex?vr>lockedRound_p ) 或如果 ![]( http://latex.codecogs.com/svg.latex?lockedValue=v )（见第 29 行）。否则，正确的进程将通过发送带有 ![]( http://latex.codecogs.com/svg.latex?nil ) 值的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息来拒绝该提案。如果 ![]( http://latex.codecogs.com/svg.latex?timeoutPropose ) 过期（当正确的进程开始新一轮时触发）并且进程在当前轮中尚未发送 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息（参见第 57 行），正确的进程也会发送 ![]( http://latex.codecogs.com/svg.latex?nil ) 值的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息。

如果正确的进程接收到某个值 ![]( http://latex.codecogs.com/svg.latex?v ) 的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息和 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息，那么它会发送带有 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息。否则，它发送值为 ![]( http://latex.codecogs.com/svg.latex?nil ) 的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )。一个正确的进程也会发送带有 ![]( http://latex.codecogs.com/svg.latex?nil ) 值的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息，以防 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote ) 过期（当一个正确的进程发送 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息并收到任何 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息时启动）并且一个进程在当前轮中还没有发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息（参见第 65 行）。如果一个正确的进程在某个轮次中收到针对 ![]( http://latex.codecogs.com/svg.latex?v ) 的 ![]( http://latex.codecogs.com/svg.latex?r ) 的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息和 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个具有 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息（参见第 51 行），则决定某个值 ![]( http://latex.codecogs.com/svg.latex?v )。为了防止算法阻塞并永远等待这个条件为真，算法 1 依赖于 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit )。它在进程接收到当前轮次的任何一组 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息后触发。如果 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit  ) 重新提交到期并且进程尚未决定，则该进程开始下一轮（参见第 65 行）。当一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?p ) 做出决定时，它会启动下一个共识实例（针对下一个高度）。 Gossip 通信属性确保导致 ![]( http://latex.codecogs.com/svg.latex?p ) 做出决定的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 和 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息最终被所有正确的进程接收，因此它们也会做出决定。

### A. 终止机制
Tendermint 通过一种新颖的机制确保终止，该机制受益于基于 gossip 的通信性质（请参阅 Gossip 通信属性）。它需要管理两个额外的变量，![]( http://latex.codecogs.com/svg.latex?value ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound )，然后由提议者在提议步骤期间使用，如上所述。当进程在轮 ![]( http://latex.codecogs.com/svg.latex?r ) 中接收到值 ![]( http://latex.codecogs.com/svg.latex?v ) 的有效 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 消息和对应的 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息时，![]( http://latex.codecogs.com/svg.latex?value ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound ) 被轮 ![]( http://latex.codecogs.com/svg.latex?r ) 中的正确进程更新为 ![]( http://latex.codecogs.com/svg.latex?v ) 和 ![]( http://latex.codecogs.com/svg.latex?r )（参见第 36 行的规则）。

我们现在简要介绍一下管理和提议 ![]( http://latex.codecogs.com/svg.latex?validValue ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound ) 如何确保终止。正式处理留至第四节。

首先要注意的是，在良好期间，由于 Gossip 通信属性，如果一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?p ) 在某个轮 ![]( http://latex.codecogs.com/svg.latex?r ) 中锁定了一个值 ![]( http://latex.codecogs.com/svg.latex?v )，那么所有正确的进程都会在 ![]( http://latex.codecogs.com/svg.latex?r ) 轮结束之前将 ![]( http://latex.codecogs.com/svg.latex?validValue ) 更新为 ![]( http://latex.codecogs.com/svg.latex?v ) 并将 ![]( http://latex.codecogs.com/svg.latex?validRound ) 更新为 ![]( http://latex.codecogs.com/svg.latex?r )（我们在第四节中正式证明了这一点）。直觉是，导致 ![]( http://latex.codecogs.com/svg.latex?p ) 在第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮中锁定值 ![]( http://latex.codecogs.com/svg.latex?v ) 的消息将在第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮结束之前被传递给所有正确的进程，因此它将更新 ![]( http://latex.codecogs.com/svg.latex?validValue ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound )（第 36 行）。因此，如果一个正确的进程在良好期间锁定了某个值，则所有正确的进程都会更新 ![]( http://latex.codecogs.com/svg.latex?validValue ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound )，以便所有正确的进程都可以接受后续轮次中提出的值。请注意，在正常期间可能会发生这样的情况，没有正确的进程锁定一个值，但某些正确的进程 ![]( http://latex.codecogs.com/svg.latex?q ) 在某个回合中更新了 ![]( http://latex.codecogs.com/svg.latex?validValue ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound )。由于在这种情况下没有正确的进程锁定一个值，所有正确的进程也可以接受 ![]( http://latex.codecogs.com/svg.latex?validValue_q ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound_q )，因为对于每个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c )，![]( http://latex.codecogs.com/svg.latex?validRound_q>lockedRound_c ) 并且因为 Gossip 通信属性确保 ![]( http://latex.codecogs.com/svg.latex?q ) 在该轮中收到的相应 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息 ![]( http://latex.codecogs.com/svg.latex?validRound_q ) 在 ![]( http://latex.codecogs.com/svg.latex?\bigtriangleup ) 时间后被所有正确的进程接收。

最后，可能会发生在 ![]( http://latex.codecogs.com/svg.latex?GST ) 之后，有一个很长的轮次序列，其中没有正确的进程既不会锁定值也不会更新 ![]( http://latex.codecogs.com/svg.latex?validValue ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound )。在这种情况下，在这一系列轮次中，正确进程建议的建议值并未被所有正确进程接受。请注意，此轮次序列始终是有限的，因为在每一轮开始时，至少有一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c )，因此每个正确的进程都可以接受 ![]( http://latex.codecogs.com/svg.latex?validValue_c ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound_c )。这是正确的，因为存在一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c )，使得对于每个其他正确的进程 ![]( http://latex.codecogs.com/svg.latex?p )，![]( http://latex.codecogs.com/svg.latex?validRound_c>lockedRound_p ) 或 ![]( http://latex.codecogs.com/svg.latex?validValue_c=lockedValue_p )。这是正确的，因为 ![]( http://latex.codecogs.com/svg.latex?c ) 是在所有正确进程中的最近一轮中锁定了一个值的进程（或者没有正确的进程锁定任何值）。因此，最终 ![]( http://latex.codecogs.com/svg.latex?c ) 在某一轮中将是正确的，并且建议的值将被所有正确的进程接受，因此终止该轮序列。

因此，更新 ![]( http://latex.codecogs.com/svg.latex?validValue ) 和 ![]( http://latex.codecogs.com/svg.latex?validRound ) 变量，以及 Gossip 通信属性，共同确保最终，在良好时期，存在一个具有正确提议者的轮，其提议的值将被所有正确的进程和所有正确的进程接受将在该轮结束。请注意，该机制与图 1 中所示的通用终止机制相反，除了作为通常称为“正常”情况的一部分已发送的消息之外，不需要交换任何其他信息。

## IV. TENDERMINT 共识算法的证明
**引理 1.**   
对于所有 ![]( http://latex.codecogs.com/svg.latex?f\geq0 )，投票权至少等于 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  的任意两组进程至少有一个共同的正确进程。

证明：由于总投票权等于 ![]( http://latex.codecogs.com/svg.latex?n=3f+1 )，我们有 ![]( http://latex.codecogs.com/svg.latex?2(2f+1)=n+f+1 )。这意味着投票权等于 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 的两个集合的交集包含至少 ![]( http://latex.codecogs.com/svg.latex?f+1 ) 个共同投票权，即至少有一个正确的进程（因为错误进程的总投票权为 ![]( http://latex.codecogs.com/svg.latex?f )）。结果直接由此而来。

**引理 2.**  
如果 ![]( http://latex.codecogs.com/svg.latex?f+1 ) 在轮 ![]( http://latex.codecogs.com/svg.latex?r_0 ) 中正确处理锁定值 ![]( http://latex.codecogs.com/svg.latex?v(lockedValue=v,lockedRound=r_0) )，那么在所有轮 ![]( http://latex.codecogs.com/svg.latex?r>r_0 ) 中，它们发送 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 或 ![]( http://latex.codecogs.com/svg.latex?nil ) 的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )。

证明：我们通过对 ![]( http://latex.codecogs.com/svg.latex?r ) 的归纳来证明结果。

基本步骤 ![]( http://latex.codecogs.com/svg.latex?r=r_0+1 ) ：让我们用 ![]( http://latex.codecogs.com/svg.latex?C ) 表示投票权等于 ![]( http://latex.codecogs.com/svg.latex?f+1 ) 的正确进程集。根据第 22 行和第 28 行的规则，来自集合 ![]( http://latex.codecogs.com/svg.latex?C ) 的进程不能接受任何值的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) 与第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮中的 ![]( http://latex.codecogs.com/svg.latex?v ) 不同，因此不能发送 ![]( http://latex.codecogs.com/svg.latex?<PREVOTE,height_p,r,id(v')> ) 消息，如果 ![]( http://latex.codecogs.com/svg.latex?v'$$\neq$$v )。因此，引理适用于基本步骤。

从 ![]( http://latex.codecogs.com/svg.latex?r_1 ) 到 ![]( http://latex.codecogs.com/svg.latex?r_1+1 ) 的归纳步骤：我们假设在第 ![]( http://latex.codecogs.com/svg.latex?r_1+1 ) 轮之前，集合 ![]( http://latex.codecogs.com/svg.latex?C ) 中的任何进程都没有为不同于 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 或 ![]( http://latex.codecogs.com/svg.latex?nil ) 的值发送 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )。我们现在证明引理也适用于第 ![]( http://latex.codecogs.com/svg.latex?r_1+1 ) 轮. 由于来自集合 ![]( http://latex.codecogs.com/svg.latex?C ) 的进程在 ![]( http://latex.codecogs.com/svg.latex?r_0$$\leq$$r$$\leq$$r_1 ) 轮中发送 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 或 ![]( http://latex.codecogs.com/svg.latex?nil ) 的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )，根据引理 1，没有值 ![]( http://latex.codecogs.com/svg.latex?v'$$\neq$$v ) 可以接收 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息第 ![]( http://latex.codecogs.com/svg.latex?(i) ) 轮。因此，对于集合 ![]( http://latex.codecogs.com/svg.latex?C ) 中的所有进程，![]( http://latex.codecogs.com/svg.latex?lockedValue=v ) 并且![]( http://latex.codecogs.com/svg.latex?lockedRound$$\geq$$r_0 )。让我们通过一个矛盾假设，来自集合 ![]( http://latex.codecogs.com/svg.latex?C ) 的进程 ![]( http://latex.codecogs.com/svg.latex?q ) 在第 ![]( http://latex.codecogs.com/svg.latex?r_1+1 ) 轮中为值 ![]( http://latex.codecogs.com/svg.latex?id(v') ) 发送 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )，其中 ![]( http://latex.codecogs.com/svg.latex?v'$$\neq$$v )。这只有在第 30 行才有可能。请注意，这意味着 ![]( http://latex.codecogs.com/svg.latex?q ) 收到 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?<PREVOTE,h_q,r,id(v'))> ) 消息，其中 ![]( http://latex.codecogs.com/svg.latex?r>r_0 ) 和 ![]( http://latex.codecogs.com/svg.latex?r<r_1+1 )（见第 29 行）。与 ![]( http://latex.codecogs.com/svg.latex?(i) ) 和引理 1 的矛盾。

**引理 3.**   
算法 1 满足***Agreement***。

证明：设轮 ![]( http://latex.codecogs.com/svg.latex?r_0 ) 是第一轮高度 ![]( http://latex.codecogs.com/svg.latex?h ) 使得某个正确的过程 ![]( http://latex.codecogs.com/svg.latex?p ) 决定 ![]( http://latex.codecogs.com/svg.latex?v )。我们现在证明如果某个正确的过程 ![]( http://latex.codecogs.com/svg.latex?q ) 在某轮 ![]( http://latex.codecogs.com/svg.latex?r$$\geq$$r_0 ) 中决定 ![]( http://latex.codecogs.com/svg.latex?v' )，则 ![]( http://latex.codecogs.com/svg.latex?v=v' )。

如果 ![]( http://latex.codecogs.com/svg.latex?r=r_0 )，![]( http://latex.codecogs.com/svg.latex?q ) 在第 49 行至少收到 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?<PRECOMMIT,h_p,r_0,id(v')> ) 消息，而 ![]( http://latex.codecogs.com/svg.latex?p ) 至少收到 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?<PRECOMMIT,h_p,r_0,id(v)> ) 消息。根据引理 1，两组投票权为 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 的消息在至少一个正确的过程中相交。由于一个正确的进程在一轮中发送单个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息，则 ![]( http://latex.codecogs.com/svg.latex?v=v' )。

我们通过反证法证明了 ![]( http://latex.codecogs.com/svg.latex?r>r_0 ) 的情况。根据规则 49，![]( http://latex.codecogs.com/svg.latex?p ) 已收到至少 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个投票权等价的 ![]( http://latex.codecogs.com/svg.latex?<PRECOMMIT,h_p,r_0,id(v)> ) 消息，即，至少 ![]( http://latex.codecogs.com/svg.latex?f+1 ) 个投票权等价的正确进程已将值 ![]( http://latex.codecogs.com/svg.latex?v ) 锁定在轮 ![]( http://latex.codecogs.com/svg.latex?r_0 ) 并发送了这些消息 ![]( http://latex.codecogs.com/svg.latex?(i) )。让这组消息用 ![]( http://latex.codecogs.com/svg.latex?C ) 表示。另一方面，![]( http://latex.codecogs.com/svg.latex?q ) 至少收到了 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个投票权，相当于 ![]( http://latex.codecogs.com/svg.latex?<PRECOMMIT,h_q,r,id(v')> ) 消息。由于所有故障进程的投票权最多为 ![]( http://latex.codecogs.com/svg.latex?f )，因此某个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c ) 发送了其中一条消息。根据第 36 行的规则，在发送 ![]( http://latex.codecogs.com/svg.latex?<PRECOMMIT,h_q,r,id(v')> ) 之前，![]( http://latex.codecogs.com/svg.latex?c ) 在第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮中锁定了值 ![]( http://latex.codecogs.com/svg.latex?v' )。因此，![]( http://latex.codecogs.com/svg.latex?c ) 在 ![]( http://latex.codecogs.com/svg.latex?r>r_0 ) 轮中收到了 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?id(v') ) 的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息（见第 36 行）。根据引理 1，来自集合 ![]( http://latex.codecogs.com/svg.latex?C ) 的进程已在第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮中为 ![]( http://latex.codecogs.com/svg.latex?id(v') ) 发送了 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息。与 ![]( http://latex.codecogs.com/svg.latex?(i) ) 和引理 2 的矛盾。

**引理 4.**   
算法 1 满足***Validity***

证明：简单地遵循第 50 行的规则，该规则确保只能确定有效值。

**引理 5.**   
如果我们假设：
- 一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?p ) 是第一个在时间 ![]( http://latex.codecogs.com/svg.latex?t>GST ) 时进入轮次 ![]( http://latex.codecogs.com/svg.latex?r>0 ) 的正确进程（对于每个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c )，时间 ![]( http://latex.codecogs.com/svg.latex?t,round_c$$\leq$$r )）
- 第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮的提议者是一个正确的过程 ![]( http://latex.codecogs.com/svg.latex?q )
- 对于每个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c )，![]( http://latex.codecogs.com/svg.latex?lockedRound_c$$\leq$$validRound_q ) 在时间 ![]( http://latex.codecogs.com/svg.latex?t )  
- ![]( http://latex.codecogs.com/svg.latex?timeoutPropose(r)>2\bigtriangleup+timeoutPrecommit(r-1) ), ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r)>2\bigtriangleup,timeoutPrecommit(r)>2\bigtriangleup )   

然后所有正确的进程在 ![]( http://latex.codecogs.com/svg.latex?t+4\bigtriangleup+timeoutPrecommit(r-1) ) 之前的第 ![]( http://latex.codecogs.com/svg.latex?r ) 轮中决定。

证明：由于 ![]( http://latex.codecogs.com/svg.latex?p )  是第一个正确进入轮 ![]( http://latex.codecogs.com/svg.latex?r )  的进程，它在 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r-1) )  到期后执行第 67 行。因此，![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t )  之前的第 ![]( http://latex.codecogs.com/svg.latex?r-1 )  轮中收到了 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息。根据 Gossip 通信属性，所有正确的进程将最晚在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup ) 收到这些消息。在时间 ![]( http://latex.codecogs.com/svg.latex?t )  的 ![]( http://latex.codecogs.com/svg.latex?round<r-1 )  中的正确进程将进入轮次 ![]( http://latex.codecogs.com/svg.latex?r-1 ) （参见第 56 行的规则）并在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup ) 之前触发 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r-1) ) （参见规则 47）。因此，所有正确的进程都将在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup+timeoutPrecommit(r-1) )   ![]( http://latex.codecogs.com/svg.latex?(i) )  开始轮 ![]( http://latex.codecogs.com/svg.latex?r ) 。

在最坏的情况下，进程 ![]( http://latex.codecogs.com/svg.latex?q )  是进入第 ![]( http://latex.codecogs.com/svg.latex?r )  轮的最后一个正确进程，因此 ![]( http://latex.codecogs.com/svg.latex?q )  开始第 ![]( http://latex.codecogs.com/svg.latex?r )  轮并在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup+timeoutPrecommit(r-1) ) 发送某个值 ![]( http://latex.codecogs.com/svg.latex?v )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  消息。因此，所有正确的进程最晚在时间 ![]( http://latex.codecogs.com/svg.latex?t+2\bigtriangleup+timeoutPrecommit(r-1) ) 之前收到来自 ![]( http://latex.codecogs.com/svg.latex?q )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  消息。因此，如果 ![]( http://latex.codecogs.com/svg.latex?timeoutPropose(r)>2\bigtriangleup+timeoutPrecommit(r-1) ) ，所有正确的进程都会在 ![]( http://latex.codecogs.com/svg.latex?timeoutPropose(r) ) 过期之前收到 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  消息。

根据 (3) 和第 22 行和第 28 行的规则，所有正确的进程都将接受值 ![]( http://latex.codecogs.com/svg.latex?v )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  消息，并在时间 ![]( http://latex.codecogs.com/svg.latex?t+2\bigtriangleup+timeoutPrecommit(r-1) ) 之前为 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 发送一条 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息。请注意，根据 Gossip 通信属性，在第 28 行触发规则所需的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup ) 之前收到。

到时间 ![]( http://latex.codecogs.com/svg.latex?t+3\bigtriangleup+timeoutPrecommit(r-1) ) ，所有正确的进程都将收到针对 ![]( http://latex.codecogs.com/svg.latex?v )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  和针对 ![]( http://latex.codecogs.com/svg.latex?id(v) )  的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 条相应的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息。根据第 36 行的规则，所有正确的进程将在时间 ![]( http://latex.codecogs.com/svg.latex?t+3\bigtriangleup+timeoutPrecommit(r-1) ) 之前为 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息（参见第 40 行）。因此，到时间 ![]( http://latex.codecogs.com/svg.latex?t+4\bigtriangleup+timeoutPrecommit(r-1) ) 时，所有正确的进程都将收到针对 ![]( http://latex.codecogs.com/svg.latex?v )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  和针对 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息，因此它们在第 51 行决定 ![]( http://latex.codecogs.com/svg.latex?v ) 。

如果每个正确的进程 ![]( http://latex.codecogs.com/svg.latex?q )  在 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r) ) 到期之前发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息，并且如果 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r) )  在 ![]( http://latex.codecogs.com/svg.latex?t+4\bigtriangleup+timeoutPrecommit(r-1) )  之前没有到期，则这种情况成立。让我们假设一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c_1 )  是第一个在时间 ![]( http://latex.codecogs.com/svg.latex?t_1>t ) 触发 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r) ) 的正确进程（参见第 34 行的规则）。这意味着在时间 ![]( http://latex.codecogs.com/svg.latex?t_1 )  之前，![]( http://latex.codecogs.com/svg.latex?c_1 )  收到了一个 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL ) （![]( http://latex.codecogs.com/svg.latex?step_c_1 )  必须由第 34 行的规则预先投票）和一组 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息。到时间 ![]( http://latex.codecogs.com/svg.latex?t_1+\bigtriangleup ) ，所有正确的进程都会收到这些消息。请注意，即使某个正确的过程在时间 ![]( http://latex.codecogs.com/svg.latex?t_1 )  之前处于较小的一轮中，在时间 ![]( http://latex.codecogs.com/svg.latex?t_1+\bigtriangleup ) 它也会在收到这些消息后开始轮 ![]( http://latex.codecogs.com/svg.latex?r ) （参见第 55 行的规则）。因此，所有正确的进程都将在时间 ![]( http://latex.codecogs.com/svg.latex?t_1+\bigtriangleup ) 之前发送其针对 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息，并且所有正确的进程将在时间 ![]( http://latex.codecogs.com/svg.latex?t_1+2\bigtriangleup ) 之前接收这些消息。因此，当 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r)>2\bigtriangleup ) 时，这确保了所有正确的进程在它们各自的本地 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r) )  到期之前从所有正确的进程接收到 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息。

另一方面，![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r) ) 是在正确的进程 ![]( http://latex.codecogs.com/svg.latex?c_2 )  中第一次接收到任何一组 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息后触发的。让我们用 ![]( http://latex.codecogs.com/svg.latex?t_2>t ) 表示最早的时间点 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r) )  在某个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c_2 )  中被触发。这意味着 ![]( http://latex.codecogs.com/svg.latex?c_2 )  已经从正确的进程收到了至少 ![]( http://latex.codecogs.com/svg.latex?f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息，即这些进程在时间 ![]( http://latex.codecogs.com/svg.latex?t_2 )  之前已经收到了 ![]( http://latex.codecogs.com/svg.latex?v )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  和 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 的 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息。根据 Gossip 通信属性，所有正确的进程将在时间 ![]( http://latex.codecogs.com/svg.latex?t_2+\bigtriangleup ) 之前接收到这些消息，并将为 ![]( http://latex.codecogs.com/svg.latex?id(v) ) 发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息。请注意，即使某些正确的进程在时间 ![]( http://latex.codecogs.com/svg.latex?t_2 )  的轮次小于 ![]( http://latex.codecogs.com/svg.latex?r ) ，根据第 55 行的规则，它们将在时间 ![]( http://latex.codecogs.com/svg.latex?t_2+\bigtriangleup ) 之前进入轮次 ![]( http://latex.codecogs.com/svg.latex?r ) 。因此，到时间 ![]( http://latex.codecogs.com/svg.latex?t_2+2\bigtriangleup ) ，所有正确的进程都将收到针对 ![]( http://latex.codecogs.com/svg.latex?v )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  和针对 ![]( http://latex.codecogs.com/svg.latex?id(v) )  的 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息。因此，如果 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r>2\bigtriangleup) ) ，所有正确的进程将在超时到期之前做出决定。

**引理 6.**  
如果一个正确的进程 ![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t_0>GST )  在某个回合 ![]( http://latex.codecogs.com/svg.latex?r )  （![]( http://latex.codecogs.com/svg.latex?lockedValue=v )  和 ![]( http://latex.codecogs.com/svg.latex?lockedRound=r ) ）和 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r)>2\bigtriangleup )  锁定了一个值 ![]( http://latex.codecogs.com/svg.latex?v ) ，那么所有正确的进程都将 ![]( http://latex.codecogs.com/svg.latex?validValue )  设置为 ![]( http://latex.codecogs.com/svg.latex?v )  并将 ![]( http://latex.codecogs.com/svg.latex?validRound )  设置为 ![]( http://latex.codecogs.com/svg.latex?r )  在开始第 ![]( http://latex.codecogs.com/svg.latex?r+1 )  轮之前。

证明：为了证明这个引理，我们需要证明如果进程 ![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t_0 )  锁定了一个值 ![]( http://latex.codecogs.com/svg.latex?v ) ，那么在时间 ![]( http://latex.codecogs.com/svg.latex?t_0+\bigtriangleup )  之前没有正确的进程将离开轮 ![]( http://latex.codecogs.com/svg.latex?r ) （除非它已经将 ![]( http://latex.codecogs.com/svg.latex?validValue )  设置为 ![]( http://latex.codecogs.com/svg.latex?v )  并且 ![]( http://latex.codecogs.com/svg.latex?validRound )  到 ![]( http://latex.codecogs.com/svg.latex?r ) )。这足以证明这一点，因为根据 Gossip 通信属性，![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t_0 )  收到的消息和在第 36 行触发的规则将在时间 ![]( http://latex.codecogs.com/svg.latex?t_0+\bigtriangleup )  被所有正确的进程接收，所以所有正确的进程仍然在轮中r 将设置 ![]( http://latex.codecogs.com/svg.latex?validValue )  为 ![]( http://latex.codecogs.com/svg.latex?v )  并将 ![]( http://latex.codecogs.com/svg.latex?validRound )  设置为 ![]( http://latex.codecogs.com/svg.latex?r ) （根据第 36 行的规则）。为了证明这一点，我们需要计算一个正确的过程可以离开轮次 ![]( http://latex.codecogs.com/svg.latex?r )  而不将 ![]( http://latex.codecogs.com/svg.latex?validValue )  更新为 ![]( http://latex.codecogs.com/svg.latex?v )  并将 ![]( http://latex.codecogs.com/svg.latex?validRound )  更新为 ![]( http://latex.codecogs.com/svg.latex?r )  的最早时间点（我们用 ![]( http://latex.codecogs.com/svg.latex?t_1 )  表示这个时间）。如果 ![]( http://latex.codecogs.com/svg.latex?t_0+\bigtriangleup<t_1 ) ，引理是正确的。

如果进程 ![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t_0 )  锁定了一个值 ![]( http://latex.codecogs.com/svg.latex?v ) ，这意味着 ![]( http://latex.codecogs.com/svg.latex?p )  在时间 ![]( http://latex.codecogs.com/svg.latex?t_0 )  收到了针对 ![]( http://latex.codecogs.com/svg.latex?v )  和 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?<PREVOTE,h,r,id(v)> )  的有效 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  消息。这些消息中至少有 ![]( http://latex.codecogs.com/svg.latex?f+1 )  条是由正确的进程发送的。让我们将这组正确的过程表示为 ![]( http://latex.codecogs.com/svg.latex?C ) 。根据引理 1，第 ![]( http://latex.codecogs.com/svg.latex?r )  轮中的任何 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息集至少包含来自集合 ![]( http://latex.codecogs.com/svg.latex?C )  的单个消息。

让我们将正确进程 ![]( http://latex.codecogs.com/svg.latex?c_1 )  触发 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r) )  的最早时间点表示为时间 ![]( http://latex.codecogs.com/svg.latex?t ) 。这意味着 ![]( http://latex.codecogs.com/svg.latex?c_1 )  收到了 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息（参见第 34 行的规则），其中至少有一个消息是由进程 ![]( http://latex.codecogs.com/svg.latex?c_2 )  从集合 ![]( http://latex.codecogs.com/svg.latex?C )  发送的。因此，进程 ![]( http://latex.codecogs.com/svg.latex?c_2 )  在时间 ![]( http://latex.codecogs.com/svg.latex?t )  之前收到了 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  消息。根据 Gossip 通信属性，所有正确的进程将在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup )  收到轮 ![]( http://latex.codecogs.com/svg.latex?r )  的 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  和 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息。最晚的时间点 ![]( http://latex.codecogs.com/svg.latex?p )  将触发 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r) )  是 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup ) 。所以 ![]( http://latex.codecogs.com/svg.latex?p )  可以在第 ![]( http://latex.codecogs.com/svg.latex?r )  轮中锁定值 ![]( http://latex.codecogs.com/svg.latex?v )  的最新时间点是 ![]( http://latex.codecogs.com/svg.latex?t_0=t+\bigtriangleup+timeoutPrevote(r) )  （因为此时 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r) )  过期，所以一个进程发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )   ![]( http://latex.codecogs.com/svg.latex?nil )  并更新 ![]( http://latex.codecogs.com/svg.latex?step )  到 ![]( http://latex.codecogs.com/svg.latex?precommit ) ，见行61)。

注意根据算法1，一个正确的进程在收到 ![]( http://latex.codecogs.com/svg.latex?2f+1 ) 个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE ) 消息之前是不能发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 消息的。因此，在时间 ![]( http://latex.codecogs.com/svg.latex?t )  之前，没有正确的进程可以在第 ![]( http://latex.codecogs.com/svg.latex?r )  轮中发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息。如果一个正确的进程为 ![]( http://latex.codecogs.com/svg.latex?nil )  发送了 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息，这意味着它已经等待了 ![]( http://latex.codecogs.com/svg.latex?timeoutPrevote(r) )  的整个持续时间（参见第 63 行）。因此，在时间 ![]( http://latex.codecogs.com/svg.latex?t+timeoutPrevote(r)(*) )  之前，没有正确的进程可以为 ![]( http://latex.codecogs.com/svg.latex?nil )  发送 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) 。

进入第 ![]( http://latex.codecogs.com/svg.latex?r+1 )  轮的正确进程 ![]( http://latex.codecogs.com/svg.latex?q )  必须等待 (i) ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r) ) （参见第 67 行）或（ii）从第 ![]( http://latex.codecogs.com/svg.latex?r+1 )  轮接收 ![]( http://latex.codecogs.com/svg.latex?f+1 )  条消息（参见第 55 行）。在前一种情况下，![]( http://latex.codecogs.com/svg.latex?q )  在开始 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r) )  之前收到 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息。如果来自正确进程的至少一条 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息（由正确的进程发送至少与这些消息相当的 ![]( http://latex.codecogs.com/svg.latex?f+1 )  投票权）为 ![]( http://latex.codecogs.com/svg.latex?nil ) ，则 ![]( http://latex.codecogs.com/svg.latex?q )  无法在时间 ![]( http://latex.codecogs.com/svg.latex?t_1=t+timeoutPrevote(r)+timeoutPrecommit(r) ) （见 ![]( http://latex.codecogs.com/svg.latex?(*) ) ）。因此，在这种情况下，我们有：![]( http://latex.codecogs.com/svg.latex?t_0+\bigtriangleup<t_1 ) ，即 ![]( http://latex.codecogs.com/svg.latex?t+2\bigtriangleup+timeoutPrevote(r)+timeoutPrecommit(r) ) ，只要 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r)>2\bigtriangleup )  就成立，所以引理在这种情况下成立。

如果在 ![]( http://latex.codecogs.com/svg.latex?q )  收到的 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  条 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息的集合中，至少有一个来自正确进程 ![]( http://latex.codecogs.com/svg.latex?c )  的 ![]( http://latex.codecogs.com/svg.latex?id(v) )  消息的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT ) ，那么 ![]( http://latex.codecogs.com/svg.latex?q )  可以最早在时间 ![]( http://latex.codecogs.com/svg.latex?t_1=t+timeoutPrecommit(r) ) 开始一轮 ![]( http://latex.codecogs.com/svg.latex?r+1 )  。在这种情况下，根据 Gossip 通信属性，所有正确的进程都将在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup )  最晚收到 ![]( http://latex.codecogs.com/svg.latex?PROPOSAL )  和 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PREVOTE )  消息（![]( http://latex.codecogs.com/svg.latex?c )  在时间 ![]( http://latex.codecogs.com/svg.latex?t )  之前收到）。因此，![]( http://latex.codecogs.com/svg.latex?q )  将在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup )  时将 ![]( http://latex.codecogs.com/svg.latex?validValue )  设置为 ![]( http://latex.codecogs.com/svg.latex?v )  并将 ![]( http://latex.codecogs.com/svg.latex?validRound )  设置为 ![]( http://latex.codecogs.com/svg.latex?r ) 。当 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup<t+timeoutPrecommit(r) )  时，只要 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r)>\bigtriangleup ) ，引理在这种情况下也成立。

在情况 (ii) 中，![]( http://latex.codecogs.com/svg.latex?q )  从第 ![]( http://latex.codecogs.com/svg.latex?r+1 )  轮中接收到来自正确进程 ![]( http://latex.codecogs.com/svg.latex?c )  的至少一条消息。如果 ![]( http://latex.codecogs.com/svg.latex?c )  接收到 ![]( http://latex.codecogs.com/svg.latex?v )  来自它收到的 ![]( http://latex.codecogs.com/svg.latex?2f+1 )  个 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息集中的某个正确进程的 ![]( http://latex.codecogs.com/svg.latex?PRECOMMIT )  消息。与上述相同的推理在这种情况下也成立，因此 ![]( http://latex.codecogs.com/svg.latex?q )  在时间 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup )  之前将 ![]( http://latex.codecogs.com/svg.latex?validValue )  设置为 ![]( http://latex.codecogs.com/svg.latex?v )  并将 ![]( http://latex.codecogs.com/svg.latex?validRound )  设置为 ![]( http://latex.codecogs.com/svg.latex?r ) 。当 ![]( http://latex.codecogs.com/svg.latex?t+\bigtriangleup<t+timeoutPrecommit(r) ) 时，只要 ![]( http://latex.codecogs.com/svg.latex?timeoutPrecommit(r)>\bigtriangleup ) ，引理在这种情况下也成立。

**引理 7.**  
算法 1 满足***Termination***。

证明：引理 5 定义了一个场景，所有正确的过程都在其中做出决定。我们现在证明，在 ![]( http://latex.codecogs.com/svg.latex?GST )  之后的有限时间内，这种情况将会出现。假设在 ![]( http://latex.codecogs.com/svg.latex?GST )  时刻，由正确进程开始的最高轮次是 ![]( http://latex.codecogs.com/svg.latex?r_0 ) ，并且存在正确的进程 ![]( http://latex.codecogs.com/svg.latex?p ) ，使得以下成立：对于每个正确的进程 ![]( http://latex.codecogs.com/svg.latex?c ) ，![]( http://latex.codecogs.com/svg.latex?lockedRound_c$$\leq$$validRound_p ) 。此外，我们假设 ![]( http://latex.codecogs.com/svg.latex?p )  将成为某轮 ![]( http://latex.codecogs.com/svg.latex?r_1>r )  中的提议者（这是由提议者函数确保的）。

我们有两种情况需要考虑。在第一种情况下，对于所有轮次 ![]( http://latex.codecogs.com/svg.latex?r$$\geq$$r_0 )  和 ![]( http://latex.codecogs.com/svg.latex?r<r_1 ) ，没有正确的进程锁定一个值（将 ![]( http://latex.codecogs.com/svg.latex?lockedRound )  设置为 ![]( http://latex.codecogs.com/svg.latex?r ) ）。所以在第 ![]( http://latex.codecogs.com/svg.latex?r_1 )  轮中，我们有引理 5 中的场景，所以所有正确的过程都在第 ![]( http://latex.codecogs.com/svg.latex?r_1 )  轮中决定。

在第二种情况下，正确的进程在 ![]( http://latex.codecogs.com/svg.latex?r_2 )  轮中锁定了一个值 ![]( http://latex.codecogs.com/svg.latex?v ) ，其中 ![]( http://latex.codecogs.com/svg.latex?r_2$$\geq$$r_0 )  且 ![]( http://latex.codecogs.com/svg.latex?r_2<r_1 ) 。假设 ![]( http://latex.codecogs.com/svg.latex?r_2 )  是 ![]( http://latex.codecogs.com/svg.latex?r_1 )  之前的最高轮次，其中某个正确的进程 ![]( http://latex.codecogs.com/svg.latex?q )  锁定了一个值。根据引理 6，在第 ![]( http://latex.codecogs.com/svg.latex?r_2 )  轮结束时，对于所有正确的进程 ![]( http://latex.codecogs.com/svg.latex?c ) ，以下成立：![]( http://latex.codecogs.com/svg.latex?validValue_c=lockedValue_q )  和 ![]( http://latex.codecogs.com/svg.latex?validRound_c=r_2 ) 。然后在第 ![]( http://latex.codecogs.com/svg.latex?r_1 )  轮，引理 5 的条件成立，所以所有正确的过程都决定了。

## V. 结论
我们提出了一种新的拜占庭容错共识算法，它是 Tendermint BFT SMR 平台的核心。该算法是为具有大量相互不信任节点的广域网设计的，这些节点通过基于 gossip 的对等网络进行通信。它只有一种执行模式，通信模式与最先进的 PBFT 算法的“正常”情况非常相似。该算法通过利用节点之间基于gossip的通信的新颖机制确保终止。所提出的算法和证明简单而优雅，我们相信这使得它更容易理解和正确实现。


